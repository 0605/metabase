(ns metabase.feature-extraction.automagic-dashboards
  (:require [clojure
             [string :as s]
             [walk :refer [postwalk]]]
            [metabase.api
             [common :as api]
             [card :as card.api]]
            [metabase.events :as events]
            [metabase.feature-extraction.core :as fe]
            [metabase.models
             [card :as card]
             [dashboard :as dashboard :refer [Dashboard]]
             [field :refer [Field]]
             [permissions :as perms]
             [table :refer [Table]]]
            [toucan
             [db :as db]
             [hydrate :refer [hydrate]]]))

(def rules
  [{:bindings {:fields [{:named [["total" 1.0] ["amount" 0.9] ["income" 1.0] ["price" 0.6]]
                         :type :type/Number
                         :as "income"
                         :table "?orders"}
                        {:named [["created_at" 1.0] ["timestamp" 1.0] ["date" 0.8]]
                         :type :type/DateTime
                         :as "timestamp"
                         :table "?orders"}
                        {:named [["user" 1.0] ["account" 0.9] ["customer" 0.9]
                                 ["email" 0.3]]
                         :type [[:type/FK 1.0]
                                [:type/String 0.8]
                                [:type/Integer 0.4]]
                         :as "user"
                         :table "?orders"}]
               :tables [{:named [["orders" 1.0] ["transactions" 1.0] ["sales" 1.0]
                                 ["products" 0.0]]
                         :as "orders"}]}
    :cards [{:dashboard "orders autogenerated"
             :visualization :line
             :title "Income by month"
             :description ""
             :query {:source_table "?orders"
                     :breakout [[:datetime-field [:field-id "?timestamp"] :month]]
                     :aggregation [:sum [:field-id "?income"]]}}
            {:dashboard "orders autogenerated"
             :visualization :line
             :title "Unique users by month"
             :description ""
             :query {:source_table "?orders"
                     :breakout [[:datetime-field [:field-id "?timestamp"] :month]]
                     :aggregation [:distinct [:field-id "?user"]]}}]}])

(defn- boolean->probability
  [x]
  (cond
    (number? x) x
    x           1
    :else       0))

(defn- apply-rule
  [pred pattern model]
  (reduce (fn [best [pattern weight]]
            (-> pattern
                (pred model)
                boolean->probability
                (* weight)
                (max best)))
          0
          (if (vector? pattern)
            (map #(if (vector? %)
                    %
                    [% 1.0])
                 pattern)
            [[pattern 1.0]])))

(defn- name-contains?
  [pattern {:keys [name]}]
  (when (s/includes? (s/upper-case name) (s/upper-case pattern))
    (/ (count pattern)
       (count name))))

(defn- type-is?
  [t {:keys [base_type special_type]}]
  (or (isa? base_type t)
      (isa? special_type t)))

(defmulti constraint
  ^{:doc ""
    :arglists '([op model])
    :private true}
  (fn [op model]
    op))

(defmethod constraint :not-nil
  [_ field]
  (->> field (fe/extract-features {}) :features :has-nils? false?))

(defmethod constraint :unique
  [_ field]
  (->> field (fe/extract-features {}) :features :all-distinct?))

(defmethod constraint :positive
  [_ {:keys [type] :as field}]
  (if-let [min (-> type :type/Number :min)]
    (not (neg? min))
    (->> field (fe/extract-features {}) :features :positive-definite?)))

(defn- apply-rules
  [rules model]
  (reduce (fn [p-joint [pred pattern]]
            (let [p (apply-rule pred pattern model)]
              (if (pos? p)
                (* p p-joint)
                (reduced 0))))
          1
          rules))

(defn- best-match
  [rules models]
  (when (not-empty models)
    (let [rules        (remove (comp nil? second)
                               [[name-contains? (:named rules)]
                                [type-is?       (:type rules)]
                                [constraint     (:constraints rules)]])
          [model best] (->> models
                            (map (fn [model]
                                   [model (apply-rules rules model)]))
                            (apply max-key second))]
      (when (pos? best)
        model))))

(defn- template-var?
  [x]
  (and (string? x) (s/starts-with? x "?")))

(defn- unify-var
  [bindings x]
  (-> x (subs 1) bindings))

(defn- bind-models
  [database {:keys [fields tables]}]
  (let [tables (into {}
                 (map (fn [table]
                        (some->> (if database
                                   (db/select Table :db_id database)
                                   (Table))
                                 (best-match table)
                                 :id
                                 (vector (:as table)))))
                 tables)
        fields (into {}
                 (keep (fn [field]
                         (some->> (if (:table field)
                                    (when-let [table-id (->> field
                                                             :table
                                                             (unify-var tables))]
                                      (db/select Field :table_id table-id))
                                    (Field))
                                  (best-match field)
                                  :id
                                  (vector (:as field)))))
                 fields)]
    [tables fields]))

(defn- unify-vars
  [context form]
  (try
    (postwalk
     (fn [sub-form]
       (if (template-var? sub-form)
         (or (unify-var context sub-form)
             (throw (Throwable.)))
         sub-form))
     form)
    (catch Throwable _ nil)))

(defn- add-to-dashboard!
  [dashboard card]
  (let [dashboard (or (db/select-one Dashboard :name dashboard)
                      (let [dashboard (db/insert!  Dashboard
                                        :name        dashboard
                                        :description "Autogenerated dashboard"
                                        :creator_id  1 ;api/*current-user-id*
                                        :parameters  [])]
                        (events/publish-event! :dashboard-create dashboard)
                        dashboard))]
    (dashboard/add-dashcard! dashboard card)
    dashboard))

(defn- create-card!
  [{:keys [query description title visualization dashboard]}]
  (let [dataset_query {:query    query
                       :type     :query
                       :database (db/select-one-field :db_id Table
                                   :id (:source_table query))}]
    (when (or (nil? api/*current-user-id*) ;; REMOVE BEFORE SHIPPING (here for REPL convinience)
           (perms/set-has-full-permissions-for-set?
               @api/*current-user-permissions-set*
               (card/query-perms-set dataset_query :write)))
      (let [metadata (card.api/result-metadata-for-query dataset_query)
            card     (db/insert! 'Card
                       :creator_id             1 ;api/*current-user-id*
                       :dataset_query          dataset_query
                       :description            description
                       :display                visualization
                       :name                   title
                       :visualization_settings {}
                       :collection_id          nil
                       :result_metadata        metadata)]
        (events/publish-event! :card-create card)
        (hydrate card :creator :dashboard_count :labels :can_write :collection)
        (add-to-dashboard! dashboard card)))))

(defn populate-dashboards
  [database]
  (->> rules
       (mapcat (fn [{:keys [bindings cards]}]
                 (let [[tables fields] (bind-models database bindings)]
                   (keep (fn [card]
                           (when-let [query (unify-vars (merge tables fields)
                                                        (:query card))]
                             (create-card! (assoc card :query query))))
                         cards))))
       (map :id)
       distinct))
